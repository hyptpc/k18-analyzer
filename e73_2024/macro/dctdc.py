#!/usr/bin/env python3

import datetime
import logging
import multiprocessing as mp
import os
import shutil
import sys

import ROOT

import conf

logger = logging.getLogger('__main__').getChild(__name__)
tmp_dir = os.path.join(os.path.dirname(__file__), 'tmp')
os.makedirs(tmp_dir, exist_ok=True)

#______________________________________________________________________________
def fit(h1, params=None, limits=None, fitrange=(-2.5, 2.5), autozoom=False):
  f1 = ROOT.TF1('f1', '[0]*TMath::Freq((x-[1])/[2])+TMath::Abs([3])')
  f1.SetLineWidth(1)
  if params is not None:
    f1.SetParameters(params)
  if limits is not None:
    for i, l in enumerate(limits):
      f1.SetParLimits(i, l[0], l[1])
  for j in range(1):
    mean = f1.GetParameter(1)
    sigma = max(10, abs(f1.GetParameter(2)))
    h1.Fit('f1', 'Q', '', mean + fitrange[0]*sigma, mean + fitrange[1]*sigma)
  # line.DrawLine(f1.GetParameter(1), 0, f1.GetParameter(1), h1.GetMaximum())
  if autozoom:
    h1.GetXaxis().SetRangeUser(mean-10*sigma, mean+20*sigma)
  t0 = f1.GetParameter(1) + abs(f1.GetParameter(2))*2.5
  line = ROOT.TLine()
  line.SetLineWidth(1)
  line.DrawLine(t0, 0, t0, h1.GetMaximum())
  return f1, t0

#______________________________________________________________________________
def output_result(run_info, result_dict, update=False):
  logger.debug(run_info)
  dctdc_path = conf.get(run_info, 'DCTDC')
  with open(dctdc_path, 'r') as f:
    rows = [line.split() for line in f]
  output_path = os.path.join(tmp_dir, f'DCTdcParam_{run_info["key"]:05d}')
  comment = (f'# {datetime.datetime.now()} generated by '
             + f'{result_dict["generator"]}'
             + f' using {os.path.basename(run_info["root"])}')
  duplicate = dict()
  with open(output_path, 'w') as f:
    f.write(comment + '\n')
    for r in rows:
      if not r[0].isdigit():
        if r[0][0] != '#':
          r[0] = '#' + r[0]
        if len(r) < 6 or result_dict['generator'] not in r[5]:
          delimiter = ' ' if len(r[0]) == 1 else '\t'
          f.write(delimiter.join(r) + '\n')
        continue
      key = (int(r[0]), int(r[1]), int(r[2]))
      if key in result_dict and key not in duplicate:
        p0 = result_dict[key][0]
        p1 = result_dict[key][1]
        newline = '\t'.join(r[:3] + [str(p0), str(p1)])
        if (float(r[3]), float(r[4])) != (p0, p1):
          logger.debug(f'update {key} {float(r[3]), float(r[4])} -> {(p0, p1)}')
        f.write(newline + '\n')
        duplicate[key] = True
      else:
        f.write('\t'.join(r) + '\n')
    logger.info(f'generate {output_path}')
  if update:
    dctdc_dir = os.path.dirname(dctdc_path)
    logger.info(f'update {os.path.join(dctdc_dir, os.path.basename(output_path))}')
    shutil.copy2(output_path, dctdc_dir)
    conf.replace(run_info, 'DCTDC', os.path.basename(output_path))
