/**
 *  file: ScalerAnalyzer.cc
 *  date: 2017.04.10
 *
 */

#include "ScalerAnalyzer.hh"

#include <algorithm>
#include <iomanip>
#include <iostream>
#include <iterator>
#include <sstream>
#include <string>

#include <std_ostream.hh>

#include "ConfMan.hh"
#include "DetectorID.hh"
#include "DCRawHit.hh"
#include "HodoRawHit.hh"
#include "Unpacker.hh"
#include "UnpackerManager.hh"
#include "UserParamMan.hh"

namespace
{
  using namespace hddaq::unpacker;
  const std::string& class_name("ScalerAnalyzer");
  const UnpackerManager& gUnpacker = GUnpacker::get_instance();
}

//______________________________________________________________________________
ScalerAnalyzer::ScalerAnalyzer( void )
  : m_ost( std::cout ), //m_ost( hddaq::cout ),
    m_info( MaxColumn, std::vector<ScalerInfo>(MaxRow) ),
    m_spill_increment(false),
    m_separate_comma(false)
{
  Initialize();
}

//______________________________________________________________________________
ScalerAnalyzer::~ScalerAnalyzer( void )
{
}

//______________________________________________________________________________
void
ScalerAnalyzer::Clear( void )
{
  for( std::size_t i=0; i<MaxColumn; ++i ){
    for( std::size_t j=0; j<MaxRow; ++j ){
      m_info[i][j].data = 0;
    }
  }
}

//______________________________________________________________________________
bool
ScalerAnalyzer::Decode( void )
{
  static const std::string func_name("["+class_name+"::"+__func__+"()]");

  m_spill_increment = false;

  //////////////////// Trigger Flag
  {
    static const int tdc_id = gUnpacker.get_data_id("TFlag", "tdc");
    int nhit = gUnpacker.get_entries( DetIdTrig, 0, SpillEndFlag, 0, tdc_id );
    if( nhit>0 ){
      int tdc = gUnpacker.get( DetIdTrig, 0, SpillEndFlag, 0, tdc_id );
      if( tdc>0 ) m_spill_increment = true;
    }
  }

  //////////////////// Scaler Data
  for( std::size_t i=0; i<MaxColumn; ++i ){
    for( std::size_t j=0; j<MaxRow; ++j ){
      if( !m_info[i][j].flag_disp ) continue;
      int module_id = m_info[i][j].module_id;
      int channel   = m_info[i][j].channel;
      int nhit = gUnpacker.get_entries( DetIdScaler, module_id, 0, channel, 0 );
      if( nhit<=0 ) continue;
      Scaler val = gUnpacker.get( DetIdScaler, module_id, 0, channel, 0 );

      if( m_info[i][j].prev > val ){
	m_info[i][j].prev = 0;
      }

      m_info[i][j].curr  = val;
      m_info[i][j].data += val - m_info[i][j].prev;
      m_info[i][j].prev  = m_info[i][j].curr;
    }
  }

  if( m_spill_increment ){
    m_info[1][0].data++; // spill
  }

  return true;
}

//______________________________________________________________________________
Scaler
ScalerAnalyzer::Get( const std::string& name ) const
{
  static const std::string func_name("["+class_name+"::"+__func__+"()]");

  std::vector<ScalerInfo>::const_iterator itr, itr_end;
  for( std::size_t i=0; i<MaxColumn; ++i ){
    itr_end = m_info[i].end();
    for( itr=m_info[i].begin(); itr!=itr_end; ++itr ){
      if( itr->name == name ) return itr->data;
    }
  }

  hddaq::cerr << "#W " << func_name << " "
	      << "no such ScalerInfo : " << name << std::endl;

  return 0;
}

//______________________________________________________________________________
bool
ScalerAnalyzer::Initialize( void )
{
  for( std::size_t i=0; i<MaxColumn; ++i ){
    for( std::size_t j=0; j<MaxRow; ++j ){
      m_info[i][j] = ScalerInfo("n/a", i, j, false );
    }
  }

  // scaler information is defined from here.
  // using a space character is not recommended.

  // left column (counter info)
  int index = 0;
  m_info[kLeft][index++] = ScalerInfo( "K_beam",       kScaler3, 19 ); // 0
  m_info[kLeft][index++] = ScalerInfo( "Pi_beam",      kScaler3, 20 ); // 1
  m_info[kLeft][index++] = ScalerInfo( "/p_beam",      kScaler3, 21 ); // 2
  m_info[kLeft][index++] = ScalerInfo( "/p_beam(0.6)", kScaler1, 26 ); // 3
  m_info[kLeft][index++] = ScalerInfo( "BH1-OR",       kScaler3,  0 ); // 4
  m_info[kLeft][index++] = ScalerInfo( "BH1-1",        kScaler3,  1 ); // 5
  m_info[kLeft][index++] = ScalerInfo( "BH1-2",        kScaler3,  2 ); // 6
  m_info[kLeft][index++] = ScalerInfo( "BH1-3",        kScaler3,  3 ); // 7
  m_info[kLeft][index++] = ScalerInfo( "BH1-4",        kScaler3,  4 ); // 8
  m_info[kLeft][index++] = ScalerInfo( "BH1-5",        kScaler3,  5 ); // 9
  m_info[kLeft][index++] = ScalerInfo( "BH1-6",        kScaler3,  6 ); //10
  m_info[kLeft][index++] = ScalerInfo( "BH1-7",        kScaler3,  7 ); //11
  m_info[kLeft][index++] = ScalerInfo( "BH1-8",        kScaler3,  8 ); //12
  m_info[kLeft][index++] = ScalerInfo( "BH1-9",        kScaler3,  9 ); //13
  m_info[kLeft][index++] = ScalerInfo( "BH1-10",       kScaler3, 10 ); //14
  m_info[kLeft][index++] = ScalerInfo( "BH1-11",       kScaler3, 11 ); //15
  m_info[kLeft][index++] = ScalerInfo( "BH2-OR",       kScaler3, 12 ); //16
  m_info[kLeft][index++] = ScalerInfo( "BAC1",         kScaler3, 13 ); //17
  m_info[kLeft][index++] = ScalerInfo( "BAC2",         kScaler3, 14 ); //18
  m_info[kLeft][index++] = ScalerInfo( "FBH",          kScaler1, 10 ); //19
  m_info[kLeft][index++] = ScalerInfo( "PVAC",         kScaler3, 15 ); //20
  m_info[kLeft][index++] = ScalerInfo( "FAC",          kScaler3, 16 ); //21
  m_info[kLeft][index++] = ScalerInfo( "SCH",          kScaler3, 17 ); //22
  m_info[kLeft][index++] = ScalerInfo( "TOF",          kScaler3, 18 ); //23

  // right column (DAQ info)
  index = 0;
  m_info[kRight][index++] = ScalerInfo( "Spill",        kScaler1,  0 ); // 0
  m_info[kRight][index++] = ScalerInfo( "10M_Clock",    kScaler1,  1 ); // 1
  m_info[kRight][index++] = ScalerInfo( "IM",           kScaler1,  2 ); // 2
  m_info[kRight][index++] = ScalerInfo( "TM",           kScaler1,  3 ); // 3
  m_info[kRight][index++] = ScalerInfo( "Real_Time",    kScaler1,  4 ); // 4
  m_info[kRight][index++] = ScalerInfo( "Live_Time",    kScaler1,  5 ); // 5
  m_info[kRight][index++] = ScalerInfo( "L1_Req",       kScaler1,  6 ); // 6
  m_info[kRight][index++] = ScalerInfo( "L1_Acc",       kScaler1,  7 ); // 7
  m_info[kRight][index++] = ScalerInfo( "MTX-1",        kScaler1,  8 ); // 8
  m_info[kRight][index++] = ScalerInfo( "MTX-2",        kScaler1,  9 ); // 9
  m_info[kRight][index++] = ScalerInfo( "MTX-3",        kScaler1, 10 ); //10
  // m_info[kRight][index++] = ScalerInfo( "MTX-4",        kScaler1, 11 ); //11
  m_info[kRight][index++] = ScalerInfo( "MsT_Acc",      kScaler1, 12 ); //11
  m_info[kRight][index++] = ScalerInfo( "MsT_Clear",    kScaler1, 13 ); //12
  m_info[kRight][index++] = ScalerInfo( "MsT_ClearPS",  kScaler1, 14 ); //13
  m_info[kRight][index++] = ScalerInfo( "L2_Clear",     kScaler1, 15 ); //14
  m_info[kRight][index++] = ScalerInfo( "L2_Req",       kScaler1, 16 ); //15
  m_info[kRight][index++] = ScalerInfo( "L2_Acc",       kScaler1, 17 ); //16
  m_info[kRight][index++] = ScalerInfo( "(ub)",         kScaler1, 18 ); //17
  m_info[kRight][index++] = ScalerInfo( "(ub,ub)",      kScaler1, 19 ); //18
  m_info[kRight][index++] = ScalerInfo( "(Pi,TOF)",     kScaler1, 20 ); //19
  m_info[kRight][index++] = ScalerInfo( "(K,K)",        kScaler1, 21 ); //20
  m_info[kRight][index++] = ScalerInfo( "(ub)PS",       kScaler1, 22 ); //21
  m_info[kRight][index++] = ScalerInfo( "(ub,ub)PS",    kScaler1, 23 ); //22
  m_info[kRight][index++] = ScalerInfo( "(Pi,TOF)PS",   kScaler1, 24 ); //23
  m_info[kRight][index++] = ScalerInfo( "(K,K)PS",      kScaler1, 25 ); //24
  m_info[kRight][index++] = ScalerInfo( "K_in",         kScaler3, 25 ); //25
  m_info[kRight][index++] = ScalerInfo( "Pi_in",        kScaler3, 26 ); //26
  m_info[kRight][index++] = ScalerInfo( "K_out",        kScaler3, 27 ); //27
  m_info[kRight][index++] = ScalerInfo( "Pi_out",       kScaler3, 28 ); //28
  m_info[kRight][index++] = ScalerInfo( "BH1xBH2",      kScaler3, 22 ); //29
  m_info[kRight][index++] = ScalerInfo( "BH2xTOF",      kScaler3, 23 ); //30
  m_info[kRight][index++] = ScalerInfo( "PVACx/FAC",    kScaler3, 24 ); //31

  return true;
}

//______________________________________________________________________________
void
ScalerAnalyzer::Print( const std::string& arg ) const
{
  static const std::string func_name("["+class_name+"::"+__func__+"()]");

  m_ost << "\033[2J"
	<< func_name << " " << arg << std::endl;

  double real_time = (double)Get("Real_Time");
  double live_time = (double)Get("Live_Time");
  double l1_req    = (double)Get("L1_Req");
  double l1_acc    = (double)Get("L1_Acc");
  double l2_acc    = (double)Get("L2_Acc");
  double real_live = live_time/real_time;
  double daq_eff   = l1_acc/l1_req;
  double l2_eff    = l2_acc/l1_acc;
  // double kbeam     = (double)Get("K_beam");
  // double pibeam    = (double)Get("Pi_beam");
  double duty_factor = daq_eff/(1-daq_eff)*(1/real_live-1);
  if( duty_factor >= 1. ) duty_factor = 1.;

  for( std::size_t i=0; i<MaxRow; ++i ){
    if( m_separate_comma ){
      m_ost << std::left  << std::setw(16) << m_info[kLeft][i].name
	    << std::right << std::setw(16) << SeparateComma( m_info[kLeft][i].data )
	    << " : "
	    << std::left  << std::setw(16) << m_info[kRight][i].name
	    << std::right << std::setw(16) << SeparateComma( m_info[kRight][i].data )
	    <<std::endl;
    }else{
      m_ost << std::left  << std::setw(16) << m_info[kLeft][i].name
	    << std::right << std::setw(16) << m_info[kLeft][i].data
	    << " : "
	    << std::left  << std::setw(16) << m_info[kRight][i].name
	    << std::right << std::setw(16) << m_info[kRight][i].data
	    <<std::endl;
    }
  }
  m_ost << std::endl  << std::setprecision(6) << std::fixed
	<< std::left  << std::setw(16) << "Live/Real"
	<< std::right << std::setw(16) << real_live << " : "
	<< std::left  << std::setw(16) << "DAQ Eff"
	<< std::right << std::setw(16) << daq_eff << std::endl
	<< std::left  << std::setw(16) << "L2 Eff"
	<< std::right << std::setw(16) << l2_eff << " : "
	<< std::left  << std::setw(16) << "Duty Factor"
	<< std::right << std::setw(16) << duty_factor << std::endl
	<< std::endl;
}

//______________________________________________________________________________
std::string
ScalerAnalyzer::SeparateComma( Scaler number ) const
{
  std::vector<Scaler> sep_num;

  while(number/1000){
    sep_num.push_back(number%1000);
    number /= 1000;
  }

  std::stringstream ss;  ss << number;
  std::vector<Scaler>::reverse_iterator
    itr, itr_end = sep_num.rend();
  for( itr=sep_num.rbegin(); itr!=itr_end; ++itr ){
    ss << "," << std::setfill('0') << std::setw(3) << *itr;
  }
  return ss.str();
}
